# TODO: Data Structures and Algorithms

## Table of Contents
1. [Problem-Solving Paradigms](#1-problem-solving-paradigms)
2. [Advanced Topics](#2-advanced-topics)
- [Completed Implementations (archive)](#archive)

<details>
<summary><strong>Optional Implementations: Set Aside</strong></summary>
<ul>
<li><b><i>Advanced Tree Structures:</i></b><br>
[ ] Implement a B-Tree</li>
<li><b><i>Graph Algorithms:</i></b><br>
[ ] Johnson’s Algorithm for Sparse Graphs</li>
</ul>
</details>

## 1. Problem-Solving Paradigms

- ### Divide and Conquer
- [X] Binary Search (Iterative and Recursive)
- [X] Merge Sort
  - Iterative and Recursive Variants 
  - In-Depth Analysis
- [X] QuickSort
  - Algorithm and Analysis
  - Randomized Version 
- [ ] Strassen’s Matrix Multiplication 
- [ ] Recurrence Relations 
  - [ ] Substitution Method 
  - [ ] Recursion Tree Method
  - [ ] Master Theorem and Examples

- ### Greedy Algorithms
- [ ] Activity Selection Problem
- [ ] Knapsack Problem
- [ ] Job Sequencing with Deadlines
- [ ] Huffman Coding
- [ ] Optimal Merge Pattern
- [X] Minimum Spanning Trees (Prim’s and Kruskal’s)
- [X] Single-Source Shortest Path (Dijkstra)

- ### Dynamic Programming
- [ ] Principles of Dynamic Programming
- [ ] Multi-Stage Graphs
- [ ] Matrix Chain Multiplication
- [ ] Longest Common Subsequence (LCS)
- [ ] Optimal Binary Search Trees
- [ ] 0/1 Knapsack Problem
- [X] Bellman-Ford Algorithm
- [ ] Traveling Salesman Problem (TSP)
- [X] Floyd-Warshall Algorithm

- ### Backtracking
- [ ] N-Queens Problem
- [ ] Sum of Subsets
- [ ] Graph Coloring
- [ ] Hamiltonian Cycle

- ### Branch and Bound
- [ ] Job Sequencing with Deadline
- [ ] 0/1 Knapsack Problem
- [ ] Traveling Salesman Problem

## 2. Advanced Topics

- ### NP-Hard and NP-Complete Problems
- [ ] Polynomial Time
- [ ] Polynomial-Time Verification
- [ ] NP-Completeness Proofs
- [ ] NP-Complete Problems

- ### Approximation Algorithms
- [ ] Vertex Cover Problem
- [ ] Traveling Salesperson Problem (TSP)
- [ ] Set-Covering Problem
- [ ] Subset-Sum Problem

- ### Parallel Algorithms
- [ ] Basics of Fork-Join Parallelism
- [ ] Parallel Merge Sort
- [ ] Parallel Matrix Multiplication

- ### Machine Learning Algorithms
- [ ] Clustering
- [ ] Gradient Descent

## ARCHIVE
Descending order of completion

### String Matching Algorithms
- [X] Naive String-Matching Algorithm
- [X] Rabin-Karp Algorithm
- [X] Knuth-Morris-Pratt (KMP) Algorithm
- [X] Finite Automata for String Matching
- [X] Suffix Arrays

### Graph Algorithms
- [X] Graph Traversals
  - [X] Breadth-First Search (BFS)
  - [X] Depth-First Search (DFS)
- [X] Topological Sort
- [X] Strongly Connected Components

- ### Minimum Spanning Trees
- [X] Kruskal’s Algorithm
- [X] Prim’s Algorithm

- ### Shortest Path Algorithms
- [X] Dijkstra's Algorithm (Single Source Shortest Path)
- [X] Bellman-Ford Algorithm
- [X] Floyd-Warshall Algorithm

---

### Implement Advanced Tree Structures
- [X] Implement a Binary Tree
- [X] Implement a Binary Search Tree (BST)
- [X] Implement an AVL Tree (Self-balancing BST)
- [X] Implement a Red-Black Tree

---

### Union-Find (Disjoint Set)
- [X] Implement Basic Union-Find
- [X] Implement Path Compression
- [X] Implement Union by Rank

---

### Graph ( preferably using Adjacency List -> Done with both: default being list )
- Implemented all in 2 classes with 1 interface and 1 factory function
- [X] Implement Directed Graph (No Weights)
- [X] Implement Weighted Graph (Un Directed)
- [X] Implement a simple undirected graph with no weights

---

### Deque (Double-Ended Queue)
- [X] Implement Deque with Array
  - Done with Array List due to reification
- [X] Implement Deque with Linked List
  - Done with a Singly Linked List Subclass

---

### Migrate existing Java implementations to Kotlin
- [X] Stack, Queue
- [X] Linked List
- [X] Heap, Priority Queue
- [X] Trie
- [X] Hash Table
- [X] Graph
- [X] Tree