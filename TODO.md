# TODO: Data Structures and Algorithms

## Table of Contents
1. [Advanced Tree Structures](#1-implement-advanced-tree-structures)
2. [Graph Algorithms](#2-graph-algorithms)
3. [Problem-Solving Paradigms](#3-problem-solving-paradigms)
4. [String Matching Algorithms](#4-string-matching-algorithms)
5. [Advanced Topics](#5-advanced-topics)
- [Completed Implementations (archive)](#archive)

## 1. Implement Advanced Tree Structures
- [X] Implement a Binary Tree
- [X] Implement a Binary Search Tree (BST)
- [ ] Implement an AVL Tree (Self-balancing BST) [Implemented previously in Java]
- [X] Implement a Red-Black Tree
- [ ] Implement a B-Tree

## 2. Graph Algorithms
- [ ] Graph Traversals
  - [X] Breadth-First Search (BFS)
  - [ ] Depth-First Search (DFS)
- [ ] Topological Sort
- [ ] Strongly Connected Components
  
- ### Minimum Spanning Trees
- [ ] Kruskal’s Algorithm
- [ ] Prim’s Algorithm

- ### Shortest Path Algorithms
- [ ] Dijkstra's Algorithm (Single Source Shortest Path)
- [ ] Bellman-Ford Algorithm 
- [ ] Floyd-Warshall Algorithm 
- [ ] Johnson’s Algorithm for Sparse Graphs

## 3. Problem-Solving Paradigms

- ### Divide and Conquer
- [ ] Binary Search (Iterative and Recursive)
- [ ] Merge Sort 
  - Iterative and Recursive Variants 
  - In-Depth Analysis
- [ ] QuickSort 
  - Algorithm and Analysis
  - Randomized Version 
- [ ] Strassen’s Matrix Multiplication 
- [ ] Recurrence Relations 
  - [ ] Substitution Method 
  - [ ] Recursion Tree Method
  - [ ] Master Theorem and Examples

- ### Greedy Algorithms
- [ ] Activity Selection Problem
- [ ] Knapsack Problem
- [ ] Job Sequencing with Deadlines
- [ ] Huffman Coding
- [ ] Optimal Merge Pattern
- [ ] Minimum Spanning Trees (Prim’s and Kruskal’s)
- [ ] Single-Source Shortest Path (Dijkstra)

- ### Dynamic Programming
- [ ] Principles of Dynamic Programming
- [ ] Multi-Stage Graphs
- [ ] Matrix Chain Multiplication
- [ ] Longest Common Subsequence (LCS)
- [ ] Optimal Binary Search Trees
- [ ] 0/1 Knapsack Problem
- [ ] Bellman-Ford Algorithm
- [ ] Traveling Salesman Problem (TSP)
- [ ] Floyd-Warshall Algorithm

- ### Backtracking
- [ ] N-Queens Problem
- [ ] Sum of Subsets
- [ ] Graph Coloring
- [ ] Hamiltonian Cycle

- ### Branch and Bound
- [ ] Job Sequencing with Deadline
- [ ] 0/1 Knapsack Problem
- [ ] Traveling Salesman Problem

## 4. String Matching Algorithms
- [ ] Naive String-Matching Algorithm
- [ ] Rabin-Karp Algorithm
- [ ] Knuth-Morris-Pratt (KMP) Algorithm
- [ ] Finite Automata for String Matching
- [ ] Suffix Arrays

## 5. Advanced Topics

- ### NP-Hard and NP-Complete Problems
- [ ] Polynomial Time
- [ ] Polynomial-Time Verification
- [ ] NP-Completeness Proofs
- [ ] NP-Complete Problems

- ### Approximation Algorithms
- [ ] Vertex Cover Problem
- [ ] Traveling Salesperson Problem (TSP)
- [ ] Set-Covering Problem
- [ ] Subset-Sum Problem

- ### Parallel Algorithms
- [ ] Basics of Fork-Join Parallelism
- [ ] Parallel Merge Sort
- [ ] Parallel Matrix Multiplication

- ### Machine Learning Algorithms
- [ ] Clustering
- [ ] Gradient Descent

## ARCHIVE
Descending order of completion

### Union-Find (Disjoint Set)
- [X] Implement Basic Union-Find
- [X] Implement Path Compression
- [X] Implement Union by Rank

---

### Graph ( preferably using Adjacency List -> Done with both: default being list )
- Implemented all in 2 classes with 1 interface and 1 factory function
- [X] Implement Directed Graph (No Weights)
- [X] Implement Weighted Graph (Un Directed)
- [X] Implement a simple undirected graph with no weights

---

### Deque (Double-Ended Queue)
- [X] Implement Deque with Array
  - Done with Array List due to reification
- [X] Implement Deque with Linked List
  - Done with a Singly Linked List Subclass

---

### Migrate existing Java implementations to Kotlin
- [X] Stack, Queue
- [X] Linked List
- [X] Heap, Priority Queue
- [X] Trie
- [X] Hash Table
- [X] Graph
- [X] Tree